// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: sis.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type handleServerStreamingCall,
  makeGenericClientConstructor,
  Metadata,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "eduapi.async";

/** Request message for syncing entities. The filter field is a placeholder for future query support. */
export interface SyncRequest {
  /** Reserved for future filtering/scoping */
  filter: string;
}

/** IdentifierEntry message */
export interface IdentifierEntry {
  identifier: string;
  identifierType: string;
}

/** LanguageTypedString message */
export interface LanguageTypedString {
  recordLanguage: string;
  value: string;
}

/** PersonName message */
export interface PersonName {
  familyName: string;
  givenName: string;
  additionalName: string;
  patronymicName: string;
  honorificPrefix: string;
  honorificSuffix: string;
  familyNamePrefix: string;
}

/** PersonNameEntry message */
export interface PersonNameEntry {
  nameType: string;
  familyName: string;
  givenName: string;
  additionalName: string;
  patronymicName: string;
  honorificPrefix: string;
  honorificSuffix: string;
  familyNamePrefix: string;
}

/** OptionallyTypedEmail message */
export interface OptionallyTypedEmail {
  emailType: string;
  email: string;
}

/** TypedEmail message */
export interface TypedEmail {
  emailType: string;
  email: string;
}

/** OptionallyTypedPhone message */
export interface OptionallyTypedPhone {
  phoneType: string;
  phone: string;
}

/** TypedPhone message */
export interface TypedPhone {
  phoneType: string;
  phone: string;
}

/** GeoCoordinates message */
export interface GeoCoordinates {
  latitude: number;
  longitude: number;
}

/** OptionallyTypedAddress message */
export interface OptionallyTypedAddress {
  addressType: string;
  addressCountry: string;
  addressCountryCode: string;
  addressRegion: string;
  addressLocality: string;
  streetAddress: string;
  postOfficeBoxNumber: string;
  postalCode: string;
  geo: GeoCoordinates | undefined;
}

/** TypedAddress message */
export interface TypedAddress {
  addressType: string;
  addressCountry: string;
  addressCountryCode: string;
  addressRegion: string;
  addressLocality: string;
  streetAddress: string;
  postOfficeBoxNumber: string;
  postalCode: string;
  geo: GeoCoordinates | undefined;
}

/** Agents message */
export interface Agents {
  agentType: string;
  person: string;
  description: LanguageTypedString[];
  domain: string;
}

/** Person message */
export interface Person {
  sourcedId: string;
  otherIdentifiers: IdentifierEntry[];
  recordLanguage: string;
  legalName: PersonName | undefined;
  formattedName: string;
  otherNames: PersonNameEntry[];
  gender: string;
  pronouns: LanguageTypedString[];
  languagesSpoken: string[];
  dateOfBirth: string;
  placeOfBirth: string;
  countryOfBirth: string;
  isDeceased: boolean;
  dateOfDeath: string;
  primaryEmail: OptionallyTypedEmail | undefined;
  otherEmails: TypedEmail[];
  primaryPhone: OptionallyTypedPhone | undefined;
  otherPhones: TypedPhone[];
  primaryAddress: OptionallyTypedAddress | undefined;
  otherAddresses: TypedAddress[];
  agents: Agents[];
  dateLastModified: string;
  recordStatus: string;
  /** Extensions can be represented as a string (e.g., JSON) for flexibility */
  extensions: string;
}

/** Course message (based on CourseTemplate) */
export interface Course {
  courseType: string;
  parent: string[];
  sourcedId: string;
  recordLanguage: string;
  title: LanguageTypedString[];
  description: LanguageTypedString[];
  primaryCode: IdentifierEntry | undefined;
  otherCodes: IdentifierEntry[];
  organization: string;
  organizationCode: string;
  level: string;
  creditType: string;
  creditsAwarded: string;
  gradingScheme: LanguageTypedString | undefined;
  teachingLanguage: string;
  recordStatus: string;
  dateLastModified: string;
  /** Extensions can be represented as a string (e.g., JSON) for flexibility */
  extensions: string;
}

/** Used to ask consumbers to resync (DB cleaned etc) */
export interface SyncEvent {
  person?: Person | undefined;
  course?: Course | undefined;
  reset?: SyncReset | undefined;
}

export interface SyncReset {
  reason: string;
}

function createBaseSyncRequest(): SyncRequest {
  return { filter: "" };
}

export const SyncRequest: MessageFns<SyncRequest> = {
  encode(message: SyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncRequest {
    return { filter: isSet(object.filter) ? globalThis.String(object.filter) : "" };
  },

  toJSON(message: SyncRequest): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncRequest>, I>>(base?: I): SyncRequest {
    return SyncRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncRequest>, I>>(object: I): SyncRequest {
    const message = createBaseSyncRequest();
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseIdentifierEntry(): IdentifierEntry {
  return { identifier: "", identifierType: "" };
}

export const IdentifierEntry: MessageFns<IdentifierEntry> = {
  encode(message: IdentifierEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== "") {
      writer.uint32(10).string(message.identifier);
    }
    if (message.identifierType !== "") {
      writer.uint32(18).string(message.identifierType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentifierEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentifierEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifierType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentifierEntry {
    return {
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      identifierType: isSet(object.identifierType) ? globalThis.String(object.identifierType) : "",
    };
  },

  toJSON(message: IdentifierEntry): unknown {
    const obj: any = {};
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.identifierType !== "") {
      obj.identifierType = message.identifierType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdentifierEntry>, I>>(base?: I): IdentifierEntry {
    return IdentifierEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdentifierEntry>, I>>(object: I): IdentifierEntry {
    const message = createBaseIdentifierEntry();
    message.identifier = object.identifier ?? "";
    message.identifierType = object.identifierType ?? "";
    return message;
  },
};

function createBaseLanguageTypedString(): LanguageTypedString {
  return { recordLanguage: "", value: "" };
}

export const LanguageTypedString: MessageFns<LanguageTypedString> = {
  encode(message: LanguageTypedString, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recordLanguage !== "") {
      writer.uint32(10).string(message.recordLanguage);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageTypedString {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageTypedString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recordLanguage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageTypedString {
    return {
      recordLanguage: isSet(object.recordLanguage) ? globalThis.String(object.recordLanguage) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LanguageTypedString): unknown {
    const obj: any = {};
    if (message.recordLanguage !== "") {
      obj.recordLanguage = message.recordLanguage;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LanguageTypedString>, I>>(base?: I): LanguageTypedString {
    return LanguageTypedString.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LanguageTypedString>, I>>(object: I): LanguageTypedString {
    const message = createBaseLanguageTypedString();
    message.recordLanguage = object.recordLanguage ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePersonName(): PersonName {
  return {
    familyName: "",
    givenName: "",
    additionalName: "",
    patronymicName: "",
    honorificPrefix: "",
    honorificSuffix: "",
    familyNamePrefix: "",
  };
}

export const PersonName: MessageFns<PersonName> = {
  encode(message: PersonName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.familyName !== "") {
      writer.uint32(10).string(message.familyName);
    }
    if (message.givenName !== "") {
      writer.uint32(18).string(message.givenName);
    }
    if (message.additionalName !== "") {
      writer.uint32(26).string(message.additionalName);
    }
    if (message.patronymicName !== "") {
      writer.uint32(34).string(message.patronymicName);
    }
    if (message.honorificPrefix !== "") {
      writer.uint32(42).string(message.honorificPrefix);
    }
    if (message.honorificSuffix !== "") {
      writer.uint32(50).string(message.honorificSuffix);
    }
    if (message.familyNamePrefix !== "") {
      writer.uint32(58).string(message.familyNamePrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.familyName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.givenName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.additionalName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.patronymicName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.honorificPrefix = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.honorificSuffix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.familyNamePrefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonName {
    return {
      familyName: isSet(object.familyName) ? globalThis.String(object.familyName) : "",
      givenName: isSet(object.givenName) ? globalThis.String(object.givenName) : "",
      additionalName: isSet(object.additionalName) ? globalThis.String(object.additionalName) : "",
      patronymicName: isSet(object.patronymicName) ? globalThis.String(object.patronymicName) : "",
      honorificPrefix: isSet(object.honorificPrefix) ? globalThis.String(object.honorificPrefix) : "",
      honorificSuffix: isSet(object.honorificSuffix) ? globalThis.String(object.honorificSuffix) : "",
      familyNamePrefix: isSet(object.familyNamePrefix) ? globalThis.String(object.familyNamePrefix) : "",
    };
  },

  toJSON(message: PersonName): unknown {
    const obj: any = {};
    if (message.familyName !== "") {
      obj.familyName = message.familyName;
    }
    if (message.givenName !== "") {
      obj.givenName = message.givenName;
    }
    if (message.additionalName !== "") {
      obj.additionalName = message.additionalName;
    }
    if (message.patronymicName !== "") {
      obj.patronymicName = message.patronymicName;
    }
    if (message.honorificPrefix !== "") {
      obj.honorificPrefix = message.honorificPrefix;
    }
    if (message.honorificSuffix !== "") {
      obj.honorificSuffix = message.honorificSuffix;
    }
    if (message.familyNamePrefix !== "") {
      obj.familyNamePrefix = message.familyNamePrefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonName>, I>>(base?: I): PersonName {
    return PersonName.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonName>, I>>(object: I): PersonName {
    const message = createBasePersonName();
    message.familyName = object.familyName ?? "";
    message.givenName = object.givenName ?? "";
    message.additionalName = object.additionalName ?? "";
    message.patronymicName = object.patronymicName ?? "";
    message.honorificPrefix = object.honorificPrefix ?? "";
    message.honorificSuffix = object.honorificSuffix ?? "";
    message.familyNamePrefix = object.familyNamePrefix ?? "";
    return message;
  },
};

function createBasePersonNameEntry(): PersonNameEntry {
  return {
    nameType: "",
    familyName: "",
    givenName: "",
    additionalName: "",
    patronymicName: "",
    honorificPrefix: "",
    honorificSuffix: "",
    familyNamePrefix: "",
  };
}

export const PersonNameEntry: MessageFns<PersonNameEntry> = {
  encode(message: PersonNameEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nameType !== "") {
      writer.uint32(10).string(message.nameType);
    }
    if (message.familyName !== "") {
      writer.uint32(18).string(message.familyName);
    }
    if (message.givenName !== "") {
      writer.uint32(26).string(message.givenName);
    }
    if (message.additionalName !== "") {
      writer.uint32(34).string(message.additionalName);
    }
    if (message.patronymicName !== "") {
      writer.uint32(42).string(message.patronymicName);
    }
    if (message.honorificPrefix !== "") {
      writer.uint32(50).string(message.honorificPrefix);
    }
    if (message.honorificSuffix !== "") {
      writer.uint32(58).string(message.honorificSuffix);
    }
    if (message.familyNamePrefix !== "") {
      writer.uint32(66).string(message.familyNamePrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonNameEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonNameEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nameType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.familyName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.givenName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.additionalName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.patronymicName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.honorificPrefix = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.honorificSuffix = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.familyNamePrefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonNameEntry {
    return {
      nameType: isSet(object.nameType) ? globalThis.String(object.nameType) : "",
      familyName: isSet(object.familyName) ? globalThis.String(object.familyName) : "",
      givenName: isSet(object.givenName) ? globalThis.String(object.givenName) : "",
      additionalName: isSet(object.additionalName) ? globalThis.String(object.additionalName) : "",
      patronymicName: isSet(object.patronymicName) ? globalThis.String(object.patronymicName) : "",
      honorificPrefix: isSet(object.honorificPrefix) ? globalThis.String(object.honorificPrefix) : "",
      honorificSuffix: isSet(object.honorificSuffix) ? globalThis.String(object.honorificSuffix) : "",
      familyNamePrefix: isSet(object.familyNamePrefix) ? globalThis.String(object.familyNamePrefix) : "",
    };
  },

  toJSON(message: PersonNameEntry): unknown {
    const obj: any = {};
    if (message.nameType !== "") {
      obj.nameType = message.nameType;
    }
    if (message.familyName !== "") {
      obj.familyName = message.familyName;
    }
    if (message.givenName !== "") {
      obj.givenName = message.givenName;
    }
    if (message.additionalName !== "") {
      obj.additionalName = message.additionalName;
    }
    if (message.patronymicName !== "") {
      obj.patronymicName = message.patronymicName;
    }
    if (message.honorificPrefix !== "") {
      obj.honorificPrefix = message.honorificPrefix;
    }
    if (message.honorificSuffix !== "") {
      obj.honorificSuffix = message.honorificSuffix;
    }
    if (message.familyNamePrefix !== "") {
      obj.familyNamePrefix = message.familyNamePrefix;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonNameEntry>, I>>(base?: I): PersonNameEntry {
    return PersonNameEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonNameEntry>, I>>(object: I): PersonNameEntry {
    const message = createBasePersonNameEntry();
    message.nameType = object.nameType ?? "";
    message.familyName = object.familyName ?? "";
    message.givenName = object.givenName ?? "";
    message.additionalName = object.additionalName ?? "";
    message.patronymicName = object.patronymicName ?? "";
    message.honorificPrefix = object.honorificPrefix ?? "";
    message.honorificSuffix = object.honorificSuffix ?? "";
    message.familyNamePrefix = object.familyNamePrefix ?? "";
    return message;
  },
};

function createBaseOptionallyTypedEmail(): OptionallyTypedEmail {
  return { emailType: "", email: "" };
}

export const OptionallyTypedEmail: MessageFns<OptionallyTypedEmail> = {
  encode(message: OptionallyTypedEmail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailType !== "") {
      writer.uint32(10).string(message.emailType);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionallyTypedEmail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionallyTypedEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emailType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionallyTypedEmail {
    return {
      emailType: isSet(object.emailType) ? globalThis.String(object.emailType) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: OptionallyTypedEmail): unknown {
    const obj: any = {};
    if (message.emailType !== "") {
      obj.emailType = message.emailType;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OptionallyTypedEmail>, I>>(base?: I): OptionallyTypedEmail {
    return OptionallyTypedEmail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionallyTypedEmail>, I>>(object: I): OptionallyTypedEmail {
    const message = createBaseOptionallyTypedEmail();
    message.emailType = object.emailType ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseTypedEmail(): TypedEmail {
  return { emailType: "", email: "" };
}

export const TypedEmail: MessageFns<TypedEmail> = {
  encode(message: TypedEmail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailType !== "") {
      writer.uint32(10).string(message.emailType);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypedEmail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypedEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.emailType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypedEmail {
    return {
      emailType: isSet(object.emailType) ? globalThis.String(object.emailType) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: TypedEmail): unknown {
    const obj: any = {};
    if (message.emailType !== "") {
      obj.emailType = message.emailType;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypedEmail>, I>>(base?: I): TypedEmail {
    return TypedEmail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypedEmail>, I>>(object: I): TypedEmail {
    const message = createBaseTypedEmail();
    message.emailType = object.emailType ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseOptionallyTypedPhone(): OptionallyTypedPhone {
  return { phoneType: "", phone: "" };
}

export const OptionallyTypedPhone: MessageFns<OptionallyTypedPhone> = {
  encode(message: OptionallyTypedPhone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phoneType !== "") {
      writer.uint32(10).string(message.phoneType);
    }
    if (message.phone !== "") {
      writer.uint32(18).string(message.phone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionallyTypedPhone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionallyTypedPhone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.phoneType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionallyTypedPhone {
    return {
      phoneType: isSet(object.phoneType) ? globalThis.String(object.phoneType) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
    };
  },

  toJSON(message: OptionallyTypedPhone): unknown {
    const obj: any = {};
    if (message.phoneType !== "") {
      obj.phoneType = message.phoneType;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OptionallyTypedPhone>, I>>(base?: I): OptionallyTypedPhone {
    return OptionallyTypedPhone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionallyTypedPhone>, I>>(object: I): OptionallyTypedPhone {
    const message = createBaseOptionallyTypedPhone();
    message.phoneType = object.phoneType ?? "";
    message.phone = object.phone ?? "";
    return message;
  },
};

function createBaseTypedPhone(): TypedPhone {
  return { phoneType: "", phone: "" };
}

export const TypedPhone: MessageFns<TypedPhone> = {
  encode(message: TypedPhone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phoneType !== "") {
      writer.uint32(10).string(message.phoneType);
    }
    if (message.phone !== "") {
      writer.uint32(18).string(message.phone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypedPhone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypedPhone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.phoneType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypedPhone {
    return {
      phoneType: isSet(object.phoneType) ? globalThis.String(object.phoneType) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
    };
  },

  toJSON(message: TypedPhone): unknown {
    const obj: any = {};
    if (message.phoneType !== "") {
      obj.phoneType = message.phoneType;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypedPhone>, I>>(base?: I): TypedPhone {
    return TypedPhone.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypedPhone>, I>>(object: I): TypedPhone {
    const message = createBaseTypedPhone();
    message.phoneType = object.phoneType ?? "";
    message.phone = object.phone ?? "";
    return message;
  },
};

function createBaseGeoCoordinates(): GeoCoordinates {
  return { latitude: 0, longitude: 0 };
}

export const GeoCoordinates: MessageFns<GeoCoordinates> = {
  encode(message: GeoCoordinates, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoCoordinates {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoCoordinates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.latitude = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.longitude = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoCoordinates {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
    };
  },

  toJSON(message: GeoCoordinates): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeoCoordinates>, I>>(base?: I): GeoCoordinates {
    return GeoCoordinates.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeoCoordinates>, I>>(object: I): GeoCoordinates {
    const message = createBaseGeoCoordinates();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    return message;
  },
};

function createBaseOptionallyTypedAddress(): OptionallyTypedAddress {
  return {
    addressType: "",
    addressCountry: "",
    addressCountryCode: "",
    addressRegion: "",
    addressLocality: "",
    streetAddress: "",
    postOfficeBoxNumber: "",
    postalCode: "",
    geo: undefined,
  };
}

export const OptionallyTypedAddress: MessageFns<OptionallyTypedAddress> = {
  encode(message: OptionallyTypedAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addressType !== "") {
      writer.uint32(10).string(message.addressType);
    }
    if (message.addressCountry !== "") {
      writer.uint32(18).string(message.addressCountry);
    }
    if (message.addressCountryCode !== "") {
      writer.uint32(26).string(message.addressCountryCode);
    }
    if (message.addressRegion !== "") {
      writer.uint32(34).string(message.addressRegion);
    }
    if (message.addressLocality !== "") {
      writer.uint32(42).string(message.addressLocality);
    }
    if (message.streetAddress !== "") {
      writer.uint32(50).string(message.streetAddress);
    }
    if (message.postOfficeBoxNumber !== "") {
      writer.uint32(58).string(message.postOfficeBoxNumber);
    }
    if (message.postalCode !== "") {
      writer.uint32(66).string(message.postalCode);
    }
    if (message.geo !== undefined) {
      GeoCoordinates.encode(message.geo, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionallyTypedAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionallyTypedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addressType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addressCountry = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addressCountryCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addressRegion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addressLocality = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.postOfficeBoxNumber = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.geo = GeoCoordinates.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionallyTypedAddress {
    return {
      addressType: isSet(object.addressType) ? globalThis.String(object.addressType) : "",
      addressCountry: isSet(object.addressCountry) ? globalThis.String(object.addressCountry) : "",
      addressCountryCode: isSet(object.addressCountryCode) ? globalThis.String(object.addressCountryCode) : "",
      addressRegion: isSet(object.addressRegion) ? globalThis.String(object.addressRegion) : "",
      addressLocality: isSet(object.addressLocality) ? globalThis.String(object.addressLocality) : "",
      streetAddress: isSet(object.streetAddress) ? globalThis.String(object.streetAddress) : "",
      postOfficeBoxNumber: isSet(object.postOfficeBoxNumber) ? globalThis.String(object.postOfficeBoxNumber) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
      geo: isSet(object.geo) ? GeoCoordinates.fromJSON(object.geo) : undefined,
    };
  },

  toJSON(message: OptionallyTypedAddress): unknown {
    const obj: any = {};
    if (message.addressType !== "") {
      obj.addressType = message.addressType;
    }
    if (message.addressCountry !== "") {
      obj.addressCountry = message.addressCountry;
    }
    if (message.addressCountryCode !== "") {
      obj.addressCountryCode = message.addressCountryCode;
    }
    if (message.addressRegion !== "") {
      obj.addressRegion = message.addressRegion;
    }
    if (message.addressLocality !== "") {
      obj.addressLocality = message.addressLocality;
    }
    if (message.streetAddress !== "") {
      obj.streetAddress = message.streetAddress;
    }
    if (message.postOfficeBoxNumber !== "") {
      obj.postOfficeBoxNumber = message.postOfficeBoxNumber;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.geo !== undefined) {
      obj.geo = GeoCoordinates.toJSON(message.geo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OptionallyTypedAddress>, I>>(base?: I): OptionallyTypedAddress {
    return OptionallyTypedAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionallyTypedAddress>, I>>(object: I): OptionallyTypedAddress {
    const message = createBaseOptionallyTypedAddress();
    message.addressType = object.addressType ?? "";
    message.addressCountry = object.addressCountry ?? "";
    message.addressCountryCode = object.addressCountryCode ?? "";
    message.addressRegion = object.addressRegion ?? "";
    message.addressLocality = object.addressLocality ?? "";
    message.streetAddress = object.streetAddress ?? "";
    message.postOfficeBoxNumber = object.postOfficeBoxNumber ?? "";
    message.postalCode = object.postalCode ?? "";
    message.geo = (object.geo !== undefined && object.geo !== null)
      ? GeoCoordinates.fromPartial(object.geo)
      : undefined;
    return message;
  },
};

function createBaseTypedAddress(): TypedAddress {
  return {
    addressType: "",
    addressCountry: "",
    addressCountryCode: "",
    addressRegion: "",
    addressLocality: "",
    streetAddress: "",
    postOfficeBoxNumber: "",
    postalCode: "",
    geo: undefined,
  };
}

export const TypedAddress: MessageFns<TypedAddress> = {
  encode(message: TypedAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addressType !== "") {
      writer.uint32(10).string(message.addressType);
    }
    if (message.addressCountry !== "") {
      writer.uint32(18).string(message.addressCountry);
    }
    if (message.addressCountryCode !== "") {
      writer.uint32(26).string(message.addressCountryCode);
    }
    if (message.addressRegion !== "") {
      writer.uint32(34).string(message.addressRegion);
    }
    if (message.addressLocality !== "") {
      writer.uint32(42).string(message.addressLocality);
    }
    if (message.streetAddress !== "") {
      writer.uint32(50).string(message.streetAddress);
    }
    if (message.postOfficeBoxNumber !== "") {
      writer.uint32(58).string(message.postOfficeBoxNumber);
    }
    if (message.postalCode !== "") {
      writer.uint32(66).string(message.postalCode);
    }
    if (message.geo !== undefined) {
      GeoCoordinates.encode(message.geo, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypedAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addressType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addressCountry = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addressCountryCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addressRegion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addressLocality = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.postOfficeBoxNumber = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.geo = GeoCoordinates.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypedAddress {
    return {
      addressType: isSet(object.addressType) ? globalThis.String(object.addressType) : "",
      addressCountry: isSet(object.addressCountry) ? globalThis.String(object.addressCountry) : "",
      addressCountryCode: isSet(object.addressCountryCode) ? globalThis.String(object.addressCountryCode) : "",
      addressRegion: isSet(object.addressRegion) ? globalThis.String(object.addressRegion) : "",
      addressLocality: isSet(object.addressLocality) ? globalThis.String(object.addressLocality) : "",
      streetAddress: isSet(object.streetAddress) ? globalThis.String(object.streetAddress) : "",
      postOfficeBoxNumber: isSet(object.postOfficeBoxNumber) ? globalThis.String(object.postOfficeBoxNumber) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
      geo: isSet(object.geo) ? GeoCoordinates.fromJSON(object.geo) : undefined,
    };
  },

  toJSON(message: TypedAddress): unknown {
    const obj: any = {};
    if (message.addressType !== "") {
      obj.addressType = message.addressType;
    }
    if (message.addressCountry !== "") {
      obj.addressCountry = message.addressCountry;
    }
    if (message.addressCountryCode !== "") {
      obj.addressCountryCode = message.addressCountryCode;
    }
    if (message.addressRegion !== "") {
      obj.addressRegion = message.addressRegion;
    }
    if (message.addressLocality !== "") {
      obj.addressLocality = message.addressLocality;
    }
    if (message.streetAddress !== "") {
      obj.streetAddress = message.streetAddress;
    }
    if (message.postOfficeBoxNumber !== "") {
      obj.postOfficeBoxNumber = message.postOfficeBoxNumber;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.geo !== undefined) {
      obj.geo = GeoCoordinates.toJSON(message.geo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypedAddress>, I>>(base?: I): TypedAddress {
    return TypedAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypedAddress>, I>>(object: I): TypedAddress {
    const message = createBaseTypedAddress();
    message.addressType = object.addressType ?? "";
    message.addressCountry = object.addressCountry ?? "";
    message.addressCountryCode = object.addressCountryCode ?? "";
    message.addressRegion = object.addressRegion ?? "";
    message.addressLocality = object.addressLocality ?? "";
    message.streetAddress = object.streetAddress ?? "";
    message.postOfficeBoxNumber = object.postOfficeBoxNumber ?? "";
    message.postalCode = object.postalCode ?? "";
    message.geo = (object.geo !== undefined && object.geo !== null)
      ? GeoCoordinates.fromPartial(object.geo)
      : undefined;
    return message;
  },
};

function createBaseAgents(): Agents {
  return { agentType: "", person: "", description: [], domain: "" };
}

export const Agents: MessageFns<Agents> = {
  encode(message: Agents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agentType !== "") {
      writer.uint32(10).string(message.agentType);
    }
    if (message.person !== "") {
      writer.uint32(18).string(message.person);
    }
    for (const v of message.description) {
      LanguageTypedString.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.domain !== "") {
      writer.uint32(34).string(message.domain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Agents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.agentType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.person = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description.push(LanguageTypedString.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.domain = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Agents {
    return {
      agentType: isSet(object.agentType) ? globalThis.String(object.agentType) : "",
      person: isSet(object.person) ? globalThis.String(object.person) : "",
      description: globalThis.Array.isArray(object?.description)
        ? object.description.map((e: any) => LanguageTypedString.fromJSON(e))
        : [],
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
    };
  },

  toJSON(message: Agents): unknown {
    const obj: any = {};
    if (message.agentType !== "") {
      obj.agentType = message.agentType;
    }
    if (message.person !== "") {
      obj.person = message.person;
    }
    if (message.description?.length) {
      obj.description = message.description.map((e) => LanguageTypedString.toJSON(e));
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Agents>, I>>(base?: I): Agents {
    return Agents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Agents>, I>>(object: I): Agents {
    const message = createBaseAgents();
    message.agentType = object.agentType ?? "";
    message.person = object.person ?? "";
    message.description = object.description?.map((e) => LanguageTypedString.fromPartial(e)) || [];
    message.domain = object.domain ?? "";
    return message;
  },
};

function createBasePerson(): Person {
  return {
    sourcedId: "",
    otherIdentifiers: [],
    recordLanguage: "",
    legalName: undefined,
    formattedName: "",
    otherNames: [],
    gender: "",
    pronouns: [],
    languagesSpoken: [],
    dateOfBirth: "",
    placeOfBirth: "",
    countryOfBirth: "",
    isDeceased: false,
    dateOfDeath: "",
    primaryEmail: undefined,
    otherEmails: [],
    primaryPhone: undefined,
    otherPhones: [],
    primaryAddress: undefined,
    otherAddresses: [],
    agents: [],
    dateLastModified: "",
    recordStatus: "",
    extensions: "",
  };
}

export const Person: MessageFns<Person> = {
  encode(message: Person, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourcedId !== "") {
      writer.uint32(10).string(message.sourcedId);
    }
    for (const v of message.otherIdentifiers) {
      IdentifierEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.recordLanguage !== "") {
      writer.uint32(26).string(message.recordLanguage);
    }
    if (message.legalName !== undefined) {
      PersonName.encode(message.legalName, writer.uint32(34).fork()).join();
    }
    if (message.formattedName !== "") {
      writer.uint32(42).string(message.formattedName);
    }
    for (const v of message.otherNames) {
      PersonNameEntry.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.gender !== "") {
      writer.uint32(58).string(message.gender);
    }
    for (const v of message.pronouns) {
      LanguageTypedString.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.languagesSpoken) {
      writer.uint32(74).string(v!);
    }
    if (message.dateOfBirth !== "") {
      writer.uint32(82).string(message.dateOfBirth);
    }
    if (message.placeOfBirth !== "") {
      writer.uint32(90).string(message.placeOfBirth);
    }
    if (message.countryOfBirth !== "") {
      writer.uint32(98).string(message.countryOfBirth);
    }
    if (message.isDeceased !== false) {
      writer.uint32(104).bool(message.isDeceased);
    }
    if (message.dateOfDeath !== "") {
      writer.uint32(114).string(message.dateOfDeath);
    }
    if (message.primaryEmail !== undefined) {
      OptionallyTypedEmail.encode(message.primaryEmail, writer.uint32(122).fork()).join();
    }
    for (const v of message.otherEmails) {
      TypedEmail.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.primaryPhone !== undefined) {
      OptionallyTypedPhone.encode(message.primaryPhone, writer.uint32(138).fork()).join();
    }
    for (const v of message.otherPhones) {
      TypedPhone.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.primaryAddress !== undefined) {
      OptionallyTypedAddress.encode(message.primaryAddress, writer.uint32(154).fork()).join();
    }
    for (const v of message.otherAddresses) {
      TypedAddress.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.agents) {
      Agents.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.dateLastModified !== "") {
      writer.uint32(178).string(message.dateLastModified);
    }
    if (message.recordStatus !== "") {
      writer.uint32(186).string(message.recordStatus);
    }
    if (message.extensions !== "") {
      writer.uint32(194).string(message.extensions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Person {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerson();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourcedId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otherIdentifiers.push(IdentifierEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recordLanguage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.legalName = PersonName.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.formattedName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.otherNames.push(PersonNameEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.pronouns.push(LanguageTypedString.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.languagesSpoken.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dateOfBirth = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.placeOfBirth = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.countryOfBirth = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isDeceased = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dateOfDeath = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.primaryEmail = OptionallyTypedEmail.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.otherEmails.push(TypedEmail.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.primaryPhone = OptionallyTypedPhone.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.otherPhones.push(TypedPhone.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.primaryAddress = OptionallyTypedAddress.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.otherAddresses.push(TypedAddress.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.agents.push(Agents.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.dateLastModified = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.recordStatus = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.extensions = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Person {
    return {
      sourcedId: isSet(object.sourcedId) ? globalThis.String(object.sourcedId) : "",
      otherIdentifiers: globalThis.Array.isArray(object?.otherIdentifiers)
        ? object.otherIdentifiers.map((e: any) => IdentifierEntry.fromJSON(e))
        : [],
      recordLanguage: isSet(object.recordLanguage) ? globalThis.String(object.recordLanguage) : "",
      legalName: isSet(object.legalName) ? PersonName.fromJSON(object.legalName) : undefined,
      formattedName: isSet(object.formattedName) ? globalThis.String(object.formattedName) : "",
      otherNames: globalThis.Array.isArray(object?.otherNames)
        ? object.otherNames.map((e: any) => PersonNameEntry.fromJSON(e))
        : [],
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      pronouns: globalThis.Array.isArray(object?.pronouns)
        ? object.pronouns.map((e: any) => LanguageTypedString.fromJSON(e))
        : [],
      languagesSpoken: globalThis.Array.isArray(object?.languagesSpoken)
        ? object.languagesSpoken.map((e: any) => globalThis.String(e))
        : [],
      dateOfBirth: isSet(object.dateOfBirth) ? globalThis.String(object.dateOfBirth) : "",
      placeOfBirth: isSet(object.placeOfBirth) ? globalThis.String(object.placeOfBirth) : "",
      countryOfBirth: isSet(object.countryOfBirth) ? globalThis.String(object.countryOfBirth) : "",
      isDeceased: isSet(object.isDeceased) ? globalThis.Boolean(object.isDeceased) : false,
      dateOfDeath: isSet(object.dateOfDeath) ? globalThis.String(object.dateOfDeath) : "",
      primaryEmail: isSet(object.primaryEmail) ? OptionallyTypedEmail.fromJSON(object.primaryEmail) : undefined,
      otherEmails: globalThis.Array.isArray(object?.otherEmails)
        ? object.otherEmails.map((e: any) => TypedEmail.fromJSON(e))
        : [],
      primaryPhone: isSet(object.primaryPhone) ? OptionallyTypedPhone.fromJSON(object.primaryPhone) : undefined,
      otherPhones: globalThis.Array.isArray(object?.otherPhones)
        ? object.otherPhones.map((e: any) => TypedPhone.fromJSON(e))
        : [],
      primaryAddress: isSet(object.primaryAddress) ? OptionallyTypedAddress.fromJSON(object.primaryAddress) : undefined,
      otherAddresses: globalThis.Array.isArray(object?.otherAddresses)
        ? object.otherAddresses.map((e: any) => TypedAddress.fromJSON(e))
        : [],
      agents: globalThis.Array.isArray(object?.agents)
        ? object.agents.map((e: any) => Agents.fromJSON(e))
        : [],
      dateLastModified: isSet(object.dateLastModified) ? globalThis.String(object.dateLastModified) : "",
      recordStatus: isSet(object.recordStatus) ? globalThis.String(object.recordStatus) : "",
      extensions: isSet(object.extensions) ? globalThis.String(object.extensions) : "",
    };
  },

  toJSON(message: Person): unknown {
    const obj: any = {};
    if (message.sourcedId !== "") {
      obj.sourcedId = message.sourcedId;
    }
    if (message.otherIdentifiers?.length) {
      obj.otherIdentifiers = message.otherIdentifiers.map((e) => IdentifierEntry.toJSON(e));
    }
    if (message.recordLanguage !== "") {
      obj.recordLanguage = message.recordLanguage;
    }
    if (message.legalName !== undefined) {
      obj.legalName = PersonName.toJSON(message.legalName);
    }
    if (message.formattedName !== "") {
      obj.formattedName = message.formattedName;
    }
    if (message.otherNames?.length) {
      obj.otherNames = message.otherNames.map((e) => PersonNameEntry.toJSON(e));
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.pronouns?.length) {
      obj.pronouns = message.pronouns.map((e) => LanguageTypedString.toJSON(e));
    }
    if (message.languagesSpoken?.length) {
      obj.languagesSpoken = message.languagesSpoken;
    }
    if (message.dateOfBirth !== "") {
      obj.dateOfBirth = message.dateOfBirth;
    }
    if (message.placeOfBirth !== "") {
      obj.placeOfBirth = message.placeOfBirth;
    }
    if (message.countryOfBirth !== "") {
      obj.countryOfBirth = message.countryOfBirth;
    }
    if (message.isDeceased !== false) {
      obj.isDeceased = message.isDeceased;
    }
    if (message.dateOfDeath !== "") {
      obj.dateOfDeath = message.dateOfDeath;
    }
    if (message.primaryEmail !== undefined) {
      obj.primaryEmail = OptionallyTypedEmail.toJSON(message.primaryEmail);
    }
    if (message.otherEmails?.length) {
      obj.otherEmails = message.otherEmails.map((e) => TypedEmail.toJSON(e));
    }
    if (message.primaryPhone !== undefined) {
      obj.primaryPhone = OptionallyTypedPhone.toJSON(message.primaryPhone);
    }
    if (message.otherPhones?.length) {
      obj.otherPhones = message.otherPhones.map((e) => TypedPhone.toJSON(e));
    }
    if (message.primaryAddress !== undefined) {
      obj.primaryAddress = OptionallyTypedAddress.toJSON(message.primaryAddress);
    }
    if (message.otherAddresses?.length) {
      obj.otherAddresses = message.otherAddresses.map((e) => TypedAddress.toJSON(e));
    }
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => Agents.toJSON(e));
    }
    if (message.dateLastModified !== "") {
      obj.dateLastModified = message.dateLastModified;
    }
    if (message.recordStatus !== "") {
      obj.recordStatus = message.recordStatus;
    }
    if (message.extensions !== "") {
      obj.extensions = message.extensions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Person>, I>>(base?: I): Person {
    return Person.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Person>, I>>(object: I): Person {
    const message = createBasePerson();
    message.sourcedId = object.sourcedId ?? "";
    message.otherIdentifiers = object.otherIdentifiers?.map((e) => IdentifierEntry.fromPartial(e)) || [];
    message.recordLanguage = object.recordLanguage ?? "";
    message.legalName = (object.legalName !== undefined && object.legalName !== null)
      ? PersonName.fromPartial(object.legalName)
      : undefined;
    message.formattedName = object.formattedName ?? "";
    message.otherNames = object.otherNames?.map((e) => PersonNameEntry.fromPartial(e)) || [];
    message.gender = object.gender ?? "";
    message.pronouns = object.pronouns?.map((e) => LanguageTypedString.fromPartial(e)) || [];
    message.languagesSpoken = object.languagesSpoken?.map((e) => e) || [];
    message.dateOfBirth = object.dateOfBirth ?? "";
    message.placeOfBirth = object.placeOfBirth ?? "";
    message.countryOfBirth = object.countryOfBirth ?? "";
    message.isDeceased = object.isDeceased ?? false;
    message.dateOfDeath = object.dateOfDeath ?? "";
    message.primaryEmail = (object.primaryEmail !== undefined && object.primaryEmail !== null)
      ? OptionallyTypedEmail.fromPartial(object.primaryEmail)
      : undefined;
    message.otherEmails = object.otherEmails?.map((e) => TypedEmail.fromPartial(e)) || [];
    message.primaryPhone = (object.primaryPhone !== undefined && object.primaryPhone !== null)
      ? OptionallyTypedPhone.fromPartial(object.primaryPhone)
      : undefined;
    message.otherPhones = object.otherPhones?.map((e) => TypedPhone.fromPartial(e)) || [];
    message.primaryAddress = (object.primaryAddress !== undefined && object.primaryAddress !== null)
      ? OptionallyTypedAddress.fromPartial(object.primaryAddress)
      : undefined;
    message.otherAddresses = object.otherAddresses?.map((e) => TypedAddress.fromPartial(e)) || [];
    message.agents = object.agents?.map((e) => Agents.fromPartial(e)) || [];
    message.dateLastModified = object.dateLastModified ?? "";
    message.recordStatus = object.recordStatus ?? "";
    message.extensions = object.extensions ?? "";
    return message;
  },
};

function createBaseCourse(): Course {
  return {
    courseType: "",
    parent: [],
    sourcedId: "",
    recordLanguage: "",
    title: [],
    description: [],
    primaryCode: undefined,
    otherCodes: [],
    organization: "",
    organizationCode: "",
    level: "",
    creditType: "",
    creditsAwarded: "",
    gradingScheme: undefined,
    teachingLanguage: "",
    recordStatus: "",
    dateLastModified: "",
    extensions: "",
  };
}

export const Course: MessageFns<Course> = {
  encode(message: Course, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.courseType !== "") {
      writer.uint32(10).string(message.courseType);
    }
    for (const v of message.parent) {
      writer.uint32(18).string(v!);
    }
    if (message.sourcedId !== "") {
      writer.uint32(26).string(message.sourcedId);
    }
    if (message.recordLanguage !== "") {
      writer.uint32(34).string(message.recordLanguage);
    }
    for (const v of message.title) {
      LanguageTypedString.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.description) {
      LanguageTypedString.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.primaryCode !== undefined) {
      IdentifierEntry.encode(message.primaryCode, writer.uint32(58).fork()).join();
    }
    for (const v of message.otherCodes) {
      IdentifierEntry.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.organization !== "") {
      writer.uint32(74).string(message.organization);
    }
    if (message.organizationCode !== "") {
      writer.uint32(82).string(message.organizationCode);
    }
    if (message.level !== "") {
      writer.uint32(90).string(message.level);
    }
    if (message.creditType !== "") {
      writer.uint32(98).string(message.creditType);
    }
    if (message.creditsAwarded !== "") {
      writer.uint32(106).string(message.creditsAwarded);
    }
    if (message.gradingScheme !== undefined) {
      LanguageTypedString.encode(message.gradingScheme, writer.uint32(114).fork()).join();
    }
    if (message.teachingLanguage !== "") {
      writer.uint32(122).string(message.teachingLanguage);
    }
    if (message.recordStatus !== "") {
      writer.uint32(130).string(message.recordStatus);
    }
    if (message.dateLastModified !== "") {
      writer.uint32(138).string(message.dateLastModified);
    }
    if (message.extensions !== "") {
      writer.uint32(146).string(message.extensions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Course {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCourse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.courseType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parent.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourcedId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recordLanguage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title.push(LanguageTypedString.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description.push(LanguageTypedString.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.primaryCode = IdentifierEntry.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.otherCodes.push(IdentifierEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.organization = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.organizationCode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.creditType = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.creditsAwarded = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gradingScheme = LanguageTypedString.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.teachingLanguage = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.recordStatus = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.dateLastModified = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.extensions = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Course {
    return {
      courseType: isSet(object.courseType) ? globalThis.String(object.courseType) : "",
      parent: globalThis.Array.isArray(object?.parent) ? object.parent.map((e: any) => globalThis.String(e)) : [],
      sourcedId: isSet(object.sourcedId) ? globalThis.String(object.sourcedId) : "",
      recordLanguage: isSet(object.recordLanguage) ? globalThis.String(object.recordLanguage) : "",
      title: globalThis.Array.isArray(object?.title)
        ? object.title.map((e: any) => LanguageTypedString.fromJSON(e))
        : [],
      description: globalThis.Array.isArray(object?.description)
        ? object.description.map((e: any) => LanguageTypedString.fromJSON(e))
        : [],
      primaryCode: isSet(object.primaryCode) ? IdentifierEntry.fromJSON(object.primaryCode) : undefined,
      otherCodes: globalThis.Array.isArray(object?.otherCodes)
        ? object.otherCodes.map((e: any) => IdentifierEntry.fromJSON(e))
        : [],
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
      organizationCode: isSet(object.organizationCode) ? globalThis.String(object.organizationCode) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      creditType: isSet(object.creditType) ? globalThis.String(object.creditType) : "",
      creditsAwarded: isSet(object.creditsAwarded) ? globalThis.String(object.creditsAwarded) : "",
      gradingScheme: isSet(object.gradingScheme) ? LanguageTypedString.fromJSON(object.gradingScheme) : undefined,
      teachingLanguage: isSet(object.teachingLanguage) ? globalThis.String(object.teachingLanguage) : "",
      recordStatus: isSet(object.recordStatus) ? globalThis.String(object.recordStatus) : "",
      dateLastModified: isSet(object.dateLastModified) ? globalThis.String(object.dateLastModified) : "",
      extensions: isSet(object.extensions) ? globalThis.String(object.extensions) : "",
    };
  },

  toJSON(message: Course): unknown {
    const obj: any = {};
    if (message.courseType !== "") {
      obj.courseType = message.courseType;
    }
    if (message.parent?.length) {
      obj.parent = message.parent;
    }
    if (message.sourcedId !== "") {
      obj.sourcedId = message.sourcedId;
    }
    if (message.recordLanguage !== "") {
      obj.recordLanguage = message.recordLanguage;
    }
    if (message.title?.length) {
      obj.title = message.title.map((e) => LanguageTypedString.toJSON(e));
    }
    if (message.description?.length) {
      obj.description = message.description.map((e) => LanguageTypedString.toJSON(e));
    }
    if (message.primaryCode !== undefined) {
      obj.primaryCode = IdentifierEntry.toJSON(message.primaryCode);
    }
    if (message.otherCodes?.length) {
      obj.otherCodes = message.otherCodes.map((e) => IdentifierEntry.toJSON(e));
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    if (message.organizationCode !== "") {
      obj.organizationCode = message.organizationCode;
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.creditType !== "") {
      obj.creditType = message.creditType;
    }
    if (message.creditsAwarded !== "") {
      obj.creditsAwarded = message.creditsAwarded;
    }
    if (message.gradingScheme !== undefined) {
      obj.gradingScheme = LanguageTypedString.toJSON(message.gradingScheme);
    }
    if (message.teachingLanguage !== "") {
      obj.teachingLanguage = message.teachingLanguage;
    }
    if (message.recordStatus !== "") {
      obj.recordStatus = message.recordStatus;
    }
    if (message.dateLastModified !== "") {
      obj.dateLastModified = message.dateLastModified;
    }
    if (message.extensions !== "") {
      obj.extensions = message.extensions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Course>, I>>(base?: I): Course {
    return Course.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Course>, I>>(object: I): Course {
    const message = createBaseCourse();
    message.courseType = object.courseType ?? "";
    message.parent = object.parent?.map((e) => e) || [];
    message.sourcedId = object.sourcedId ?? "";
    message.recordLanguage = object.recordLanguage ?? "";
    message.title = object.title?.map((e) => LanguageTypedString.fromPartial(e)) || [];
    message.description = object.description?.map((e) => LanguageTypedString.fromPartial(e)) || [];
    message.primaryCode = (object.primaryCode !== undefined && object.primaryCode !== null)
      ? IdentifierEntry.fromPartial(object.primaryCode)
      : undefined;
    message.otherCodes = object.otherCodes?.map((e) => IdentifierEntry.fromPartial(e)) || [];
    message.organization = object.organization ?? "";
    message.organizationCode = object.organizationCode ?? "";
    message.level = object.level ?? "";
    message.creditType = object.creditType ?? "";
    message.creditsAwarded = object.creditsAwarded ?? "";
    message.gradingScheme = (object.gradingScheme !== undefined && object.gradingScheme !== null)
      ? LanguageTypedString.fromPartial(object.gradingScheme)
      : undefined;
    message.teachingLanguage = object.teachingLanguage ?? "";
    message.recordStatus = object.recordStatus ?? "";
    message.dateLastModified = object.dateLastModified ?? "";
    message.extensions = object.extensions ?? "";
    return message;
  },
};

function createBaseSyncEvent(): SyncEvent {
  return { person: undefined, course: undefined, reset: undefined };
}

export const SyncEvent: MessageFns<SyncEvent> = {
  encode(message: SyncEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.person !== undefined) {
      Person.encode(message.person, writer.uint32(10).fork()).join();
    }
    if (message.course !== undefined) {
      Course.encode(message.course, writer.uint32(18).fork()).join();
    }
    if (message.reset !== undefined) {
      SyncReset.encode(message.reset, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.person = Person.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.course = Course.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reset = SyncReset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncEvent {
    return {
      person: isSet(object.person) ? Person.fromJSON(object.person) : undefined,
      course: isSet(object.course) ? Course.fromJSON(object.course) : undefined,
      reset: isSet(object.reset) ? SyncReset.fromJSON(object.reset) : undefined,
    };
  },

  toJSON(message: SyncEvent): unknown {
    const obj: any = {};
    if (message.person !== undefined) {
      obj.person = Person.toJSON(message.person);
    }
    if (message.course !== undefined) {
      obj.course = Course.toJSON(message.course);
    }
    if (message.reset !== undefined) {
      obj.reset = SyncReset.toJSON(message.reset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncEvent>, I>>(base?: I): SyncEvent {
    return SyncEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncEvent>, I>>(object: I): SyncEvent {
    const message = createBaseSyncEvent();
    message.person = (object.person !== undefined && object.person !== null)
      ? Person.fromPartial(object.person)
      : undefined;
    message.course = (object.course !== undefined && object.course !== null)
      ? Course.fromPartial(object.course)
      : undefined;
    message.reset = (object.reset !== undefined && object.reset !== null)
      ? SyncReset.fromPartial(object.reset)
      : undefined;
    return message;
  },
};

function createBaseSyncReset(): SyncReset {
  return { reason: "" };
}

export const SyncReset: MessageFns<SyncReset> = {
  encode(message: SyncReset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncReset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncReset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncReset {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: SyncReset): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncReset>, I>>(base?: I): SyncReset {
    return SyncReset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncReset>, I>>(object: I): SyncReset {
    const message = createBaseSyncReset();
    message.reason = object.reason ?? "";
    return message;
  },
};

/** SIS Sync service definition */
export type SISSyncService = typeof SISSyncService;
export const SISSyncService = {
  syncPersons: {
    path: "/eduapi.async.SISSync/SyncPersons",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SyncRequest) => Buffer.from(SyncRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SyncRequest.decode(value),
    responseSerialize: (value: SyncEvent) => Buffer.from(SyncEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SyncEvent.decode(value),
  },
  syncCourses: {
    path: "/eduapi.async.SISSync/SyncCourses",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SyncRequest) => Buffer.from(SyncRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SyncRequest.decode(value),
    responseSerialize: (value: SyncEvent) => Buffer.from(SyncEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SyncEvent.decode(value),
  },
} as const;

export interface SISSyncServer extends UntypedServiceImplementation {
  syncPersons: handleServerStreamingCall<SyncRequest, SyncEvent>;
  syncCourses: handleServerStreamingCall<SyncRequest, SyncEvent>;
}

export interface SISSyncClient extends Client {
  syncPersons(request: SyncRequest, options?: Partial<CallOptions>): ClientReadableStream<SyncEvent>;
  syncPersons(
    request: SyncRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SyncEvent>;
  syncCourses(request: SyncRequest, options?: Partial<CallOptions>): ClientReadableStream<SyncEvent>;
  syncCourses(
    request: SyncRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SyncEvent>;
}

export const SISSyncClient = makeGenericClientConstructor(SISSyncService, "eduapi.async.SISSync") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SISSyncClient;
  service: typeof SISSyncService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
